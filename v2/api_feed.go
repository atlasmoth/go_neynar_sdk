
/*
 * Farcaster API V2
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * API version: 2.0
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package swagger

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type FeedApiService service
/*
FeedApiService Retrieve casts based on filters
Retrieve casts based on filters. Ensure setting the correct parameters based on the feed_type and filter_type.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param apiKey API key required for authentication.
 * @param feedType Defaults to following (requires fid or address). If set to filter (requires filter_type)
 * @param optional nil or *FeedApiFeedOpts - Optional Parameters:
     * @param "FilterType" (optional.Interface of FilterType) -  Used when feed_type&#x3D;filter. Can be set to fids (requires fids) or parent_url (requires parent_url) or channel_id (requires channel_id)
     * @param "Fid" (optional.Interface of int32) -  (Optional) fid of user whose feed you want to create. By default, the API expects this field, except if you pass a filter_type
     * @param "Fids" (optional.String) -  Used when filter_type&#x3D;fids . Create a feed based on a list of fids. Max array size is 250. Requires feed_type and filter_type.
     * @param "ParentUrl" (optional.String) -  Used when filter_type&#x3D;parent_url can be used to fetch content under any parent url e.g. FIP-2 channels on Warpcast. Requires feed_type and filter_type
     * @param "ChannelId" (optional.String) -  Used when filter_type&#x3D;channel_id can be used to fetch all casts under a channel. Requires feed_type and filter_type
     * @param "EmbedUrl" (optional.String) -  Used when filter_type&#x3D;embed_url can be used to fetch all casts with an embed url that contains embed_url. Requires feed_type and filter_type
     * @param "EmbedTypes" (optional.Interface of []EmbedType) -  Used when filter_type&#x3D;embed_types can be used to fetch all casts with matching content types. Requires feed_type and filter_type
     * @param "WithRecasts" (optional.Bool) -  Include recasts in the response, true by default
     * @param "Limit" (optional.Int32) -  Number of results to retrieve (default 25, max 100)
     * @param "Cursor" (optional.String) -  Pagination cursor.
     * @param "ViewerFid" (optional.Interface of int32) - 
@return FeedResponse
*/

type FeedApiFeedOpts struct {
    FilterType optional.Interface
    Fid optional.Interface
    Fids optional.String
    ParentUrl optional.String
    ChannelId optional.String
    EmbedUrl optional.String
    EmbedTypes optional.Interface
    WithRecasts optional.Bool
    Limit optional.Int32
    Cursor optional.String
    ViewerFid optional.Interface
}

func (a *FeedApiService) Feed(ctx context.Context, apiKey string, feedType FeedType, localVarOptionals *FeedApiFeedOpts) (FeedResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FeedResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/farcaster/feed"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("feed_type", parameterToString(feedType, ""))
	if localVarOptionals != nil && localVarOptionals.FilterType.IsSet() {
		localVarQueryParams.Add("filter_type", parameterToString(localVarOptionals.FilterType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fid.IsSet() {
		localVarQueryParams.Add("fid", parameterToString(localVarOptionals.Fid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fids.IsSet() {
		localVarQueryParams.Add("fids", parameterToString(localVarOptionals.Fids.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ParentUrl.IsSet() {
		localVarQueryParams.Add("parent_url", parameterToString(localVarOptionals.ParentUrl.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ChannelId.IsSet() {
		localVarQueryParams.Add("channel_id", parameterToString(localVarOptionals.ChannelId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EmbedUrl.IsSet() {
		localVarQueryParams.Add("embed_url", parameterToString(localVarOptionals.EmbedUrl.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EmbedTypes.IsSet() {
		localVarQueryParams.Add("embed_types", parameterToString(localVarOptionals.EmbedTypes.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.WithRecasts.IsSet() {
		localVarQueryParams.Add("with_recasts", parameterToString(localVarOptionals.WithRecasts.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cursor.IsSet() {
		localVarQueryParams.Add("cursor", parameterToString(localVarOptionals.Cursor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ViewerFid.IsSet() {
		localVarQueryParams.Add("viewer_fid", parameterToString(localVarOptionals.ViewerFid.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarHeaderParams["api_key"] = parameterToString(apiKey, "")
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v FeedResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
FeedApiService Retrieve feed based on channel ids
Retrieve feed based on channel ids
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param apiKey API key required for authentication.
 * @param channelIds Comma separated list of channel ids e.g. neynar,farcaster
 * @param optional nil or *FeedApiFeedChannelsOpts - Optional Parameters:
     * @param "WithRecasts" (optional.Bool) -  Include recasts in the response, true by default
     * @param "ViewerFid" (optional.Interface of int32) - 
     * @param "WithReplies" (optional.Bool) -  Include replies in the response, false by default
     * @param "Limit" (optional.Int32) -  Number of results to retrieve (default 25, max 100)
     * @param "Cursor" (optional.String) -  Pagination cursor.
     * @param "ShouldModerate" (optional.Bool) -  If true, only casts that have been liked by the moderator (if one exists) will be returned.
@return FeedResponse
*/

type FeedApiFeedChannelsOpts struct {
    WithRecasts optional.Bool
    ViewerFid optional.Interface
    WithReplies optional.Bool
    Limit optional.Int32
    Cursor optional.String
    ShouldModerate optional.Bool
}

func (a *FeedApiService) FeedChannels(ctx context.Context, apiKey string, channelIds string, localVarOptionals *FeedApiFeedChannelsOpts) (FeedResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FeedResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/farcaster/feed/channels"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("channel_ids", parameterToString(channelIds, ""))
	if localVarOptionals != nil && localVarOptionals.WithRecasts.IsSet() {
		localVarQueryParams.Add("with_recasts", parameterToString(localVarOptionals.WithRecasts.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ViewerFid.IsSet() {
		localVarQueryParams.Add("viewer_fid", parameterToString(localVarOptionals.ViewerFid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WithReplies.IsSet() {
		localVarQueryParams.Add("with_replies", parameterToString(localVarOptionals.WithReplies.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cursor.IsSet() {
		localVarQueryParams.Add("cursor", parameterToString(localVarOptionals.Cursor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ShouldModerate.IsSet() {
		localVarQueryParams.Add("should_moderate", parameterToString(localVarOptionals.ShouldModerate.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarHeaderParams["api_key"] = parameterToString(apiKey, "")
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v FeedResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
FeedApiService Retrieve feed based on who a user is following
Retrieve feed based on who a user is following
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param apiKey API key required for authentication.
 * @param fid fid of user whose feed you want to create
 * @param optional nil or *FeedApiFeedFollowingOpts - Optional Parameters:
     * @param "ViewerFid" (optional.Interface of int32) - 
     * @param "WithRecasts" (optional.Bool) -  Include recasts in the response, true by default
     * @param "Limit" (optional.Int32) -  Number of results to retrieve (default 25, max 100)
     * @param "Cursor" (optional.String) -  Pagination cursor.
@return FeedResponse
*/

type FeedApiFeedFollowingOpts struct {
    ViewerFid optional.Interface
    WithRecasts optional.Bool
    Limit optional.Int32
    Cursor optional.String
}

func (a *FeedApiService) FeedFollowing(ctx context.Context, apiKey string, fid int32, localVarOptionals *FeedApiFeedFollowingOpts) (FeedResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FeedResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/farcaster/feed/following"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("fid", parameterToString(fid, ""))
	if localVarOptionals != nil && localVarOptionals.ViewerFid.IsSet() {
		localVarQueryParams.Add("viewer_fid", parameterToString(localVarOptionals.ViewerFid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WithRecasts.IsSet() {
		localVarQueryParams.Add("with_recasts", parameterToString(localVarOptionals.WithRecasts.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cursor.IsSet() {
		localVarQueryParams.Add("cursor", parameterToString(localVarOptionals.Cursor.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarHeaderParams["api_key"] = parameterToString(apiKey, "")
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v FeedResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
FeedApiService Retrieve a personalized For You feed for a user
Retrieve a personalized For You feed for a user
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param apiKey API key required for authentication.
 * @param fid fid of user whose feed you want to create
 * @param optional nil or *FeedApiFeedForYouOpts - Optional Parameters:
     * @param "ViewerFid" (optional.Interface of int32) - 
     * @param "Provider" (optional.Interface of ForYouProvider) - 
     * @param "Limit" (optional.Int32) -  Number of results to retrieve (default 25, max 50)
     * @param "Cursor" (optional.String) -  Pagination cursor.
@return FeedResponse
*/

type FeedApiFeedForYouOpts struct {
    ViewerFid optional.Interface
    Provider optional.Interface
    Limit optional.Int32
    Cursor optional.String
}

func (a *FeedApiService) FeedForYou(ctx context.Context, apiKey string, fid int32, localVarOptionals *FeedApiFeedForYouOpts) (FeedResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FeedResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/farcaster/feed/for_you"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("fid", parameterToString(fid, ""))
	if localVarOptionals != nil && localVarOptionals.ViewerFid.IsSet() {
		localVarQueryParams.Add("viewer_fid", parameterToString(localVarOptionals.ViewerFid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Provider.IsSet() {
		localVarQueryParams.Add("provider", parameterToString(localVarOptionals.Provider.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cursor.IsSet() {
		localVarQueryParams.Add("cursor", parameterToString(localVarOptionals.Cursor.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarHeaderParams["api_key"] = parameterToString(apiKey, "")
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v FeedResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
FeedApiService Retrieve feed of casts with Frames, reverse chronological order
Retrieve feed of casts with Frames, reverse chronological order
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param apiKey API key required for authentication.
 * @param optional nil or *FeedApiFeedFramesOpts - Optional Parameters:
     * @param "Limit" (optional.Int32) -  Number of results to retrieve (default 25, max 100)
     * @param "ViewerFid" (optional.Interface of int32) - 
     * @param "Cursor" (optional.String) -  Pagination cursor.
@return FeedResponse
*/

type FeedApiFeedFramesOpts struct {
    Limit optional.Int32
    ViewerFid optional.Interface
    Cursor optional.String
}

func (a *FeedApiService) FeedFrames(ctx context.Context, apiKey string, localVarOptionals *FeedApiFeedFramesOpts) (FeedResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FeedResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/farcaster/feed/frames"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ViewerFid.IsSet() {
		localVarQueryParams.Add("viewer_fid", parameterToString(localVarOptionals.ViewerFid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cursor.IsSet() {
		localVarQueryParams.Add("cursor", parameterToString(localVarOptionals.Cursor.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarHeaderParams["api_key"] = parameterToString(apiKey, "")
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v FeedResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
FeedApiService Retrieve feed based on parent urls
Retrieve feed based on parent urls
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param apiKey API key required for authentication.
 * @param parentUrls Comma separated list of parent_urls
 * @param optional nil or *FeedApiFeedParentUrlsOpts - Optional Parameters:
     * @param "WithRecasts" (optional.Bool) -  Include recasts in the response, true by default
     * @param "ViewerFid" (optional.Interface of int32) - 
     * @param "WithReplies" (optional.Bool) -  Include replies in the response, false by default
     * @param "Limit" (optional.Int32) -  Number of results to retrieve (default 25, max 100)
     * @param "Cursor" (optional.String) -  Pagination cursor.
@return FeedResponse
*/

type FeedApiFeedParentUrlsOpts struct {
    WithRecasts optional.Bool
    ViewerFid optional.Interface
    WithReplies optional.Bool
    Limit optional.Int32
    Cursor optional.String
}

func (a *FeedApiService) FeedParentUrls(ctx context.Context, apiKey string, parentUrls string, localVarOptionals *FeedApiFeedParentUrlsOpts) (FeedResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FeedResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/farcaster/feed/parent_urls"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("parent_urls", parameterToString(parentUrls, ""))
	if localVarOptionals != nil && localVarOptionals.WithRecasts.IsSet() {
		localVarQueryParams.Add("with_recasts", parameterToString(localVarOptionals.WithRecasts.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ViewerFid.IsSet() {
		localVarQueryParams.Add("viewer_fid", parameterToString(localVarOptionals.ViewerFid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WithReplies.IsSet() {
		localVarQueryParams.Add("with_replies", parameterToString(localVarOptionals.WithReplies.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cursor.IsSet() {
		localVarQueryParams.Add("cursor", parameterToString(localVarOptionals.Cursor.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarHeaderParams["api_key"] = parameterToString(apiKey, "")
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v FeedResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
FeedApiService Retrieve trending casts
Retrieve trending casts or on the global feed or channels feeds. 7d time window available for channel feeds only.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param apiKey API key required for authentication.
 * @param optional nil or *FeedApiFeedTrendingOpts - Optional Parameters:
     * @param "Limit" (optional.Int32) -  Number of results to retrieve (max 10)
     * @param "Cursor" (optional.String) -  Pagination cursor
     * @param "ViewerFid" (optional.Interface of int32) - 
     * @param "TimeWindow" (optional.String) -  Time window for trending casts (7d window for channel feeds only)
     * @param "ChannelId" (optional.String) -  Channel ID to filter trending casts. Less active channels might have no casts in the time window selected.
     * @param "Provider" (optional.Interface of FeedTrendingProvider) -  The provider of the trending casts feed.
@return FeedResponse
*/

type FeedApiFeedTrendingOpts struct {
    Limit optional.Int32
    Cursor optional.String
    ViewerFid optional.Interface
    TimeWindow optional.String
    ChannelId optional.String
    Provider optional.Interface
}

func (a *FeedApiService) FeedTrending(ctx context.Context, apiKey string, localVarOptionals *FeedApiFeedTrendingOpts) (FeedResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FeedResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/farcaster/feed/trending"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cursor.IsSet() {
		localVarQueryParams.Add("cursor", parameterToString(localVarOptionals.Cursor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ViewerFid.IsSet() {
		localVarQueryParams.Add("viewer_fid", parameterToString(localVarOptionals.ViewerFid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TimeWindow.IsSet() {
		localVarQueryParams.Add("time_window", parameterToString(localVarOptionals.TimeWindow.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ChannelId.IsSet() {
		localVarQueryParams.Add("channel_id", parameterToString(localVarOptionals.ChannelId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Provider.IsSet() {
		localVarQueryParams.Add("provider", parameterToString(localVarOptionals.Provider.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarHeaderParams["api_key"] = parameterToString(apiKey, "")
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v FeedResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v InlineResponse400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 404 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
FeedApiService Retrieve casts for a user
Retrieve casts for a given user FID in reverse chronological order. Also allows filtering by parent_url and channel
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param apiKey API key required for authentication.
 * @param fid FID of user whose recent casts you want to fetch
 * @param optional nil or *FeedApiFeedUserCastsOpts - Optional Parameters:
     * @param "ViewerFid" (optional.Interface of int32) -  FID of the user viewing the feed
     * @param "Limit" (optional.Int32) -  Number of results to retrieve (default 25, max 50)
     * @param "Cursor" (optional.String) -  Pagination cursor
     * @param "IncludeReplies" (optional.Bool) -  Include reply casts by the author in the response, true by default
     * @param "ParentUrl" (optional.String) -  Parent URL to filter the feed; mutually exclusive with channel_id
     * @param "ChannelId" (optional.String) -  Channel ID to filter the feed; mutually exclusive with parent_url
@return FeedResponse
*/

type FeedApiFeedUserCastsOpts struct {
    ViewerFid optional.Interface
    Limit optional.Int32
    Cursor optional.String
    IncludeReplies optional.Bool
    ParentUrl optional.String
    ChannelId optional.String
}

func (a *FeedApiService) FeedUserCasts(ctx context.Context, apiKey string, fid int32, localVarOptionals *FeedApiFeedUserCastsOpts) (FeedResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FeedResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/farcaster/feed/user/casts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("fid", parameterToString(fid, ""))
	if localVarOptionals != nil && localVarOptionals.ViewerFid.IsSet() {
		localVarQueryParams.Add("viewer_fid", parameterToString(localVarOptionals.ViewerFid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cursor.IsSet() {
		localVarQueryParams.Add("cursor", parameterToString(localVarOptionals.Cursor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IncludeReplies.IsSet() {
		localVarQueryParams.Add("include_replies", parameterToString(localVarOptionals.IncludeReplies.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ParentUrl.IsSet() {
		localVarQueryParams.Add("parent_url", parameterToString(localVarOptionals.ParentUrl.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ChannelId.IsSet() {
		localVarQueryParams.Add("channel_id", parameterToString(localVarOptionals.ChannelId.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarHeaderParams["api_key"] = parameterToString(apiKey, "")
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v FeedResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 500 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
FeedApiService Retrieve 10 most popular casts for a user
Retrieve 10 most popular casts for a given user FID; popularity based on replies, likes and recasts; sorted by most popular first
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param apiKey API key required for authentication.
 * @param fid fid of user whose feed you want to create
 * @param optional nil or *FeedApiFeedUserPopularOpts - Optional Parameters:
     * @param "ViewerFid" (optional.Interface of int32) - 
@return BulkCastsResponse
*/

type FeedApiFeedUserPopularOpts struct {
    ViewerFid optional.Interface
}

func (a *FeedApiService) FeedUserPopular(ctx context.Context, apiKey string, fid int32, localVarOptionals *FeedApiFeedUserPopularOpts) (BulkCastsResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue BulkCastsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/farcaster/feed/user/popular"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("fid", parameterToString(fid, ""))
	if localVarOptionals != nil && localVarOptionals.ViewerFid.IsSet() {
		localVarQueryParams.Add("viewer_fid", parameterToString(localVarOptionals.ViewerFid.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarHeaderParams["api_key"] = parameterToString(apiKey, "")
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v BulkCastsResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
FeedApiService Retrieve recent replies and recasts for a user
Retrieve recent replies and recasts for a given user FID; sorted by most recent first
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param apiKey API key required for authentication.
 * @param fid fid of user whose replies and recasts you want to fetch
 * @param optional nil or *FeedApiFeedUserRepliesRecastsOpts - Optional Parameters:
     * @param "Filter" (optional.String) -  filter to fetch only replies or recasts
     * @param "Limit" (optional.Int32) -  Number of results to retrieve (default 25, max 100)
     * @param "Cursor" (optional.String) -  Pagination cursor.
     * @param "ViewerFid" (optional.Interface of int32) - 
@return FeedResponse
*/

type FeedApiFeedUserRepliesRecastsOpts struct {
    Filter optional.String
    Limit optional.Int32
    Cursor optional.String
    ViewerFid optional.Interface
}

func (a *FeedApiService) FeedUserRepliesRecasts(ctx context.Context, apiKey string, fid int32, localVarOptionals *FeedApiFeedUserRepliesRecastsOpts) (FeedResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FeedResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/farcaster/feed/user/replies_and_recasts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("fid", parameterToString(fid, ""))
	if localVarOptionals != nil && localVarOptionals.Filter.IsSet() {
		localVarQueryParams.Add("filter", parameterToString(localVarOptionals.Filter.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cursor.IsSet() {
		localVarQueryParams.Add("cursor", parameterToString(localVarOptionals.Cursor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ViewerFid.IsSet() {
		localVarQueryParams.Add("viewer_fid", parameterToString(localVarOptionals.ViewerFid.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarHeaderParams["api_key"] = parameterToString(apiKey, "")
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v FeedResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		if localVarHttpResponse.StatusCode == 400 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
