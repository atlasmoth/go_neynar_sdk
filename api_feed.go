/*
Farcaster API V2

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// FeedAPIService FeedAPI service
type FeedAPIService service

type ApiFeedRequest struct {
	ctx context.Context
	ApiService *FeedAPIService
	apiKey *string
	feedType *FeedType
	filterType *FilterType
	fid *int32
	fids *string
	parentUrl *string
	channelId *string
	embedUrl *string
	withRecasts *bool
	limit *int32
	cursor *string
	viewerFid *int32
}

// API key required for authentication.
func (r ApiFeedRequest) ApiKey(apiKey string) ApiFeedRequest {
	r.apiKey = &apiKey
	return r
}

// Defaults to following (requires fid or address). If set to filter (requires filter_type)
func (r ApiFeedRequest) FeedType(feedType FeedType) ApiFeedRequest {
	r.feedType = &feedType
	return r
}

// Used when feed_type&#x3D;filter. Can be set to fids (requires fids) or parent_url (requires parent_url) or channel_id (requires channel_id)
func (r ApiFeedRequest) FilterType(filterType FilterType) ApiFeedRequest {
	r.filterType = &filterType
	return r
}

// (Optional) fid of user whose feed you want to create. By default, the API expects this field, except if you pass a filter_type
func (r ApiFeedRequest) Fid(fid int32) ApiFeedRequest {
	r.fid = &fid
	return r
}

// Used when filter_type&#x3D;fids . Create a feed based on a list of fids. Max array size is 250. Requires feed_type and filter_type.
func (r ApiFeedRequest) Fids(fids string) ApiFeedRequest {
	r.fids = &fids
	return r
}

// Used when filter_type&#x3D;parent_url can be used to fetch content under any parent url e.g. FIP-2 channels on Warpcast. Requires feed_type and filter_type
func (r ApiFeedRequest) ParentUrl(parentUrl string) ApiFeedRequest {
	r.parentUrl = &parentUrl
	return r
}

// Used when filter_type&#x3D;channel_id can be used to fetch all casts under a channel. Requires feed_type and filter_type
func (r ApiFeedRequest) ChannelId(channelId string) ApiFeedRequest {
	r.channelId = &channelId
	return r
}

// Used when filter_type&#x3D;embed_url can be used to fetch all casts with an embed url that contains embed_url. Requires feed_type and filter_type
func (r ApiFeedRequest) EmbedUrl(embedUrl string) ApiFeedRequest {
	r.embedUrl = &embedUrl
	return r
}

// Include recasts in the response, true by default
func (r ApiFeedRequest) WithRecasts(withRecasts bool) ApiFeedRequest {
	r.withRecasts = &withRecasts
	return r
}

// Number of results to retrieve (default 25, max 100)
func (r ApiFeedRequest) Limit(limit int32) ApiFeedRequest {
	r.limit = &limit
	return r
}

// Pagination cursor.
func (r ApiFeedRequest) Cursor(cursor string) ApiFeedRequest {
	r.cursor = &cursor
	return r
}

func (r ApiFeedRequest) ViewerFid(viewerFid int32) ApiFeedRequest {
	r.viewerFid = &viewerFid
	return r
}

func (r ApiFeedRequest) Execute() (*FeedResponse, *http.Response, error) {
	return r.ApiService.FeedExecute(r)
}

/*
Feed Retrieve casts based on filters

Retrieve casts based on filters. Ensure setting the correct parameters based on the feed_type and filter_type.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFeedRequest
*/
func (a *FeedAPIService) Feed(ctx context.Context) ApiFeedRequest {
	return ApiFeedRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FeedResponse
func (a *FeedAPIService) FeedExecute(r ApiFeedRequest) (*FeedResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FeedResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FeedAPIService.Feed")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/farcaster/feed"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.apiKey == nil {
		return localVarReturnValue, nil, reportError("apiKey is required and must be specified")
	}
	if r.feedType == nil {
		return localVarReturnValue, nil, reportError("feedType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "feed_type", r.feedType, "")
	if r.filterType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter_type", r.filterType, "")
	}
	if r.fid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fid", r.fid, "")
	}
	if r.fids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fids", r.fids, "")
	}
	if r.parentUrl != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parent_url", r.parentUrl, "")
	}
	if r.channelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "channel_id", r.channelId, "")
	}
	if r.embedUrl != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "embed_url", r.embedUrl, "")
	}
	if r.withRecasts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_recasts", r.withRecasts, "")
	} else {
		var defaultValue bool = true
		r.withRecasts = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue int32 = 25
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	}
	if r.viewerFid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "viewer_fid", r.viewerFid, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "api_key", r.apiKey, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFeedChannelsRequest struct {
	ctx context.Context
	ApiService *FeedAPIService
	apiKey *string
	channelIds *string
	withRecasts *bool
	viewerFid *int32
	withReplies *bool
	limit *int32
	cursor *string
	shouldModerate *bool
}

// API key required for authentication.
func (r ApiFeedChannelsRequest) ApiKey(apiKey string) ApiFeedChannelsRequest {
	r.apiKey = &apiKey
	return r
}

// comma separated list of channel ids e.g. neynar,farcaster
func (r ApiFeedChannelsRequest) ChannelIds(channelIds string) ApiFeedChannelsRequest {
	r.channelIds = &channelIds
	return r
}

// Include recasts in the response, true by default
func (r ApiFeedChannelsRequest) WithRecasts(withRecasts bool) ApiFeedChannelsRequest {
	r.withRecasts = &withRecasts
	return r
}

func (r ApiFeedChannelsRequest) ViewerFid(viewerFid int32) ApiFeedChannelsRequest {
	r.viewerFid = &viewerFid
	return r
}

// Include replies in the response, false by default
func (r ApiFeedChannelsRequest) WithReplies(withReplies bool) ApiFeedChannelsRequest {
	r.withReplies = &withReplies
	return r
}

// Number of results to retrieve (default 25, max 100)
func (r ApiFeedChannelsRequest) Limit(limit int32) ApiFeedChannelsRequest {
	r.limit = &limit
	return r
}

// Pagination cursor.
func (r ApiFeedChannelsRequest) Cursor(cursor string) ApiFeedChannelsRequest {
	r.cursor = &cursor
	return r
}

// If true, only casts that have been liked by the moderator (if one exists) will be returned.
func (r ApiFeedChannelsRequest) ShouldModerate(shouldModerate bool) ApiFeedChannelsRequest {
	r.shouldModerate = &shouldModerate
	return r
}

func (r ApiFeedChannelsRequest) Execute() (*FeedResponse, *http.Response, error) {
	return r.ApiService.FeedChannelsExecute(r)
}

/*
FeedChannels Retrieve feed based on channel ids

Retrieve feed based on channel ids

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFeedChannelsRequest
*/
func (a *FeedAPIService) FeedChannels(ctx context.Context) ApiFeedChannelsRequest {
	return ApiFeedChannelsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FeedResponse
func (a *FeedAPIService) FeedChannelsExecute(r ApiFeedChannelsRequest) (*FeedResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FeedResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FeedAPIService.FeedChannels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/farcaster/feed/channels"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.apiKey == nil {
		return localVarReturnValue, nil, reportError("apiKey is required and must be specified")
	}
	if r.channelIds == nil {
		return localVarReturnValue, nil, reportError("channelIds is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "channel_ids", r.channelIds, "")
	if r.withRecasts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_recasts", r.withRecasts, "")
	} else {
		var defaultValue bool = true
		r.withRecasts = &defaultValue
	}
	if r.viewerFid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "viewer_fid", r.viewerFid, "")
	}
	if r.withReplies != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_replies", r.withReplies, "")
	} else {
		var defaultValue bool = false
		r.withReplies = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue int32 = 25
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	}
	if r.shouldModerate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "should_moderate", r.shouldModerate, "")
	} else {
		var defaultValue bool = false
		r.shouldModerate = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "api_key", r.apiKey, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFeedFollowingRequest struct {
	ctx context.Context
	ApiService *FeedAPIService
	apiKey *string
	fid *int32
	viewerFid *int32
	withRecasts *bool
	limit *int32
	cursor *string
}

// API key required for authentication.
func (r ApiFeedFollowingRequest) ApiKey(apiKey string) ApiFeedFollowingRequest {
	r.apiKey = &apiKey
	return r
}

// fid of user whose feed you want to create
func (r ApiFeedFollowingRequest) Fid(fid int32) ApiFeedFollowingRequest {
	r.fid = &fid
	return r
}

func (r ApiFeedFollowingRequest) ViewerFid(viewerFid int32) ApiFeedFollowingRequest {
	r.viewerFid = &viewerFid
	return r
}

// Include recasts in the response, true by default
func (r ApiFeedFollowingRequest) WithRecasts(withRecasts bool) ApiFeedFollowingRequest {
	r.withRecasts = &withRecasts
	return r
}

// Number of results to retrieve (default 25, max 100)
func (r ApiFeedFollowingRequest) Limit(limit int32) ApiFeedFollowingRequest {
	r.limit = &limit
	return r
}

// Pagination cursor.
func (r ApiFeedFollowingRequest) Cursor(cursor string) ApiFeedFollowingRequest {
	r.cursor = &cursor
	return r
}

func (r ApiFeedFollowingRequest) Execute() (*FeedResponse, *http.Response, error) {
	return r.ApiService.FeedFollowingExecute(r)
}

/*
FeedFollowing Retrieve feed based on who a user is following

Retrieve feed based on who a user is following

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFeedFollowingRequest
*/
func (a *FeedAPIService) FeedFollowing(ctx context.Context) ApiFeedFollowingRequest {
	return ApiFeedFollowingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FeedResponse
func (a *FeedAPIService) FeedFollowingExecute(r ApiFeedFollowingRequest) (*FeedResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FeedResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FeedAPIService.FeedFollowing")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/farcaster/feed/following"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.apiKey == nil {
		return localVarReturnValue, nil, reportError("apiKey is required and must be specified")
	}
	if r.fid == nil {
		return localVarReturnValue, nil, reportError("fid is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "fid", r.fid, "")
	if r.viewerFid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "viewer_fid", r.viewerFid, "")
	}
	if r.withRecasts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_recasts", r.withRecasts, "")
	} else {
		var defaultValue bool = true
		r.withRecasts = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue int32 = 25
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "api_key", r.apiKey, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFeedForYouRequest struct {
	ctx context.Context
	ApiService *FeedAPIService
	apiKey *string
	fid *int32
	viewerFid *int32
	provider *ForYouProvider
	limit *int32
	cursor *string
}

// API key required for authentication.
func (r ApiFeedForYouRequest) ApiKey(apiKey string) ApiFeedForYouRequest {
	r.apiKey = &apiKey
	return r
}

// fid of user whose feed you want to create
func (r ApiFeedForYouRequest) Fid(fid int32) ApiFeedForYouRequest {
	r.fid = &fid
	return r
}

func (r ApiFeedForYouRequest) ViewerFid(viewerFid int32) ApiFeedForYouRequest {
	r.viewerFid = &viewerFid
	return r
}

func (r ApiFeedForYouRequest) Provider(provider ForYouProvider) ApiFeedForYouRequest {
	r.provider = &provider
	return r
}

// Number of results to retrieve (default 25, max 50)
func (r ApiFeedForYouRequest) Limit(limit int32) ApiFeedForYouRequest {
	r.limit = &limit
	return r
}

// Pagination cursor.
func (r ApiFeedForYouRequest) Cursor(cursor string) ApiFeedForYouRequest {
	r.cursor = &cursor
	return r
}

func (r ApiFeedForYouRequest) Execute() (*FeedResponse, *http.Response, error) {
	return r.ApiService.FeedForYouExecute(r)
}

/*
FeedForYou Retrieve a personalized For You feed for a user

Retrieve a personalized For You feed for a user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFeedForYouRequest
*/
func (a *FeedAPIService) FeedForYou(ctx context.Context) ApiFeedForYouRequest {
	return ApiFeedForYouRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FeedResponse
func (a *FeedAPIService) FeedForYouExecute(r ApiFeedForYouRequest) (*FeedResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FeedResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FeedAPIService.FeedForYou")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/farcaster/feed/for_you"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.apiKey == nil {
		return localVarReturnValue, nil, reportError("apiKey is required and must be specified")
	}
	if r.fid == nil {
		return localVarReturnValue, nil, reportError("fid is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "fid", r.fid, "")
	if r.viewerFid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "viewer_fid", r.viewerFid, "")
	}
	if r.provider != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "provider", r.provider, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue int32 = 25
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "api_key", r.apiKey, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFeedFramesRequest struct {
	ctx context.Context
	ApiService *FeedAPIService
	apiKey *string
	limit *int32
	viewerFid *int32
	cursor *string
}

// API key required for authentication.
func (r ApiFeedFramesRequest) ApiKey(apiKey string) ApiFeedFramesRequest {
	r.apiKey = &apiKey
	return r
}

// Number of results to retrieve (default 25, max 100)
func (r ApiFeedFramesRequest) Limit(limit int32) ApiFeedFramesRequest {
	r.limit = &limit
	return r
}

func (r ApiFeedFramesRequest) ViewerFid(viewerFid int32) ApiFeedFramesRequest {
	r.viewerFid = &viewerFid
	return r
}

// Pagination cursor.
func (r ApiFeedFramesRequest) Cursor(cursor string) ApiFeedFramesRequest {
	r.cursor = &cursor
	return r
}

func (r ApiFeedFramesRequest) Execute() (*FeedResponse, *http.Response, error) {
	return r.ApiService.FeedFramesExecute(r)
}

/*
FeedFrames Retrieve feed of casts with Frames, reverse chronological order

Retrieve feed of casts with Frames, reverse chronological order

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFeedFramesRequest
*/
func (a *FeedAPIService) FeedFrames(ctx context.Context) ApiFeedFramesRequest {
	return ApiFeedFramesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FeedResponse
func (a *FeedAPIService) FeedFramesExecute(r ApiFeedFramesRequest) (*FeedResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FeedResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FeedAPIService.FeedFrames")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/farcaster/feed/frames"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.apiKey == nil {
		return localVarReturnValue, nil, reportError("apiKey is required and must be specified")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue int32 = 25
		r.limit = &defaultValue
	}
	if r.viewerFid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "viewer_fid", r.viewerFid, "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "api_key", r.apiKey, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFeedTrendingRequest struct {
	ctx context.Context
	ApiService *FeedAPIService
	apiKey *string
	limit *int32
	cursor *string
	viewerFid *int32
	timeWindow *string
	channelId *string
}

// API key required for authentication.
func (r ApiFeedTrendingRequest) ApiKey(apiKey string) ApiFeedTrendingRequest {
	r.apiKey = &apiKey
	return r
}

// Number of results to retrieve (max 10)
func (r ApiFeedTrendingRequest) Limit(limit int32) ApiFeedTrendingRequest {
	r.limit = &limit
	return r
}

// Pagination cursor
func (r ApiFeedTrendingRequest) Cursor(cursor string) ApiFeedTrendingRequest {
	r.cursor = &cursor
	return r
}

func (r ApiFeedTrendingRequest) ViewerFid(viewerFid int32) ApiFeedTrendingRequest {
	r.viewerFid = &viewerFid
	return r
}

// Time window for trending casts (7d window for channel feeds only)
func (r ApiFeedTrendingRequest) TimeWindow(timeWindow string) ApiFeedTrendingRequest {
	r.timeWindow = &timeWindow
	return r
}

// Channel ID to filter trending casts. Less active channels might have no casts in the time window selected.
func (r ApiFeedTrendingRequest) ChannelId(channelId string) ApiFeedTrendingRequest {
	r.channelId = &channelId
	return r
}

func (r ApiFeedTrendingRequest) Execute() (*FeedResponse, *http.Response, error) {
	return r.ApiService.FeedTrendingExecute(r)
}

/*
FeedTrending Retrieve trending casts

Retrieve trending casts or on the global feed or channels feeds. 7d time window available for channel feeds only.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFeedTrendingRequest
*/
func (a *FeedAPIService) FeedTrending(ctx context.Context) ApiFeedTrendingRequest {
	return ApiFeedTrendingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FeedResponse
func (a *FeedAPIService) FeedTrendingExecute(r ApiFeedTrendingRequest) (*FeedResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FeedResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FeedAPIService.FeedTrending")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/farcaster/feed/trending"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.apiKey == nil {
		return localVarReturnValue, nil, reportError("apiKey is required and must be specified")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue int32 = 10
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	}
	if r.viewerFid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "viewer_fid", r.viewerFid, "")
	}
	if r.timeWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_window", r.timeWindow, "")
	} else {
		var defaultValue string = "24h"
		r.timeWindow = &defaultValue
	}
	if r.channelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "channel_id", r.channelId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "api_key", r.apiKey, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFeedUserPopularRequest struct {
	ctx context.Context
	ApiService *FeedAPIService
	apiKey *string
	fid *int32
	viewerFid *int32
}

// API key required for authentication.
func (r ApiFeedUserPopularRequest) ApiKey(apiKey string) ApiFeedUserPopularRequest {
	r.apiKey = &apiKey
	return r
}

// fid of user whose feed you want to create
func (r ApiFeedUserPopularRequest) Fid(fid int32) ApiFeedUserPopularRequest {
	r.fid = &fid
	return r
}

func (r ApiFeedUserPopularRequest) ViewerFid(viewerFid int32) ApiFeedUserPopularRequest {
	r.viewerFid = &viewerFid
	return r
}

func (r ApiFeedUserPopularRequest) Execute() (*BulkCastsResponse, *http.Response, error) {
	return r.ApiService.FeedUserPopularExecute(r)
}

/*
FeedUserPopular Retrieve 10 most popular casts for a user

Retrieve 10 most popular casts for a given user FID; popularity based on replies, likes and recasts; sorted by most popular first

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFeedUserPopularRequest
*/
func (a *FeedAPIService) FeedUserPopular(ctx context.Context) ApiFeedUserPopularRequest {
	return ApiFeedUserPopularRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BulkCastsResponse
func (a *FeedAPIService) FeedUserPopularExecute(r ApiFeedUserPopularRequest) (*BulkCastsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BulkCastsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FeedAPIService.FeedUserPopular")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/farcaster/feed/user/popular"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.apiKey == nil {
		return localVarReturnValue, nil, reportError("apiKey is required and must be specified")
	}
	if r.fid == nil {
		return localVarReturnValue, nil, reportError("fid is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "fid", r.fid, "")
	if r.viewerFid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "viewer_fid", r.viewerFid, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "api_key", r.apiKey, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFeedUserRepliesRecastsRequest struct {
	ctx context.Context
	ApiService *FeedAPIService
	apiKey *string
	fid *int32
	filter *string
	limit *int32
	cursor *string
	viewerFid *int32
}

// API key required for authentication.
func (r ApiFeedUserRepliesRecastsRequest) ApiKey(apiKey string) ApiFeedUserRepliesRecastsRequest {
	r.apiKey = &apiKey
	return r
}

// fid of user whose replies and recasts you want to fetch
func (r ApiFeedUserRepliesRecastsRequest) Fid(fid int32) ApiFeedUserRepliesRecastsRequest {
	r.fid = &fid
	return r
}

// filter to fetch only replies or recasts
func (r ApiFeedUserRepliesRecastsRequest) Filter(filter string) ApiFeedUserRepliesRecastsRequest {
	r.filter = &filter
	return r
}

// Number of results to retrieve (default 25, max 100)
func (r ApiFeedUserRepliesRecastsRequest) Limit(limit int32) ApiFeedUserRepliesRecastsRequest {
	r.limit = &limit
	return r
}

// Pagination cursor.
func (r ApiFeedUserRepliesRecastsRequest) Cursor(cursor string) ApiFeedUserRepliesRecastsRequest {
	r.cursor = &cursor
	return r
}

func (r ApiFeedUserRepliesRecastsRequest) ViewerFid(viewerFid int32) ApiFeedUserRepliesRecastsRequest {
	r.viewerFid = &viewerFid
	return r
}

func (r ApiFeedUserRepliesRecastsRequest) Execute() (*FeedResponse, *http.Response, error) {
	return r.ApiService.FeedUserRepliesRecastsExecute(r)
}

/*
FeedUserRepliesRecasts Retrieve recent replies and recasts for a user

Retrieve recent replies and recasts for a given user FID; sorted by most recent first

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFeedUserRepliesRecastsRequest
*/
func (a *FeedAPIService) FeedUserRepliesRecasts(ctx context.Context) ApiFeedUserRepliesRecastsRequest {
	return ApiFeedUserRepliesRecastsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FeedResponse
func (a *FeedAPIService) FeedUserRepliesRecastsExecute(r ApiFeedUserRepliesRecastsRequest) (*FeedResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FeedResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FeedAPIService.FeedUserRepliesRecasts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/farcaster/feed/user/replies_and_recasts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.apiKey == nil {
		return localVarReturnValue, nil, reportError("apiKey is required and must be specified")
	}
	if r.fid == nil {
		return localVarReturnValue, nil, reportError("fid is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "fid", r.fid, "")
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	} else {
		var defaultValue string = "all"
		r.filter = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue int32 = 25
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "")
	}
	if r.viewerFid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "viewer_fid", r.viewerFid, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "api_key", r.apiKey, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
