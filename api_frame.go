/*
Farcaster API V2

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"time"
)


// FrameAPIService FrameAPI service
type FrameAPIService service

type ApiDeleteNeynarFrameRequest struct {
	ctx context.Context
	ApiService *FrameAPIService
	apiKey *string
	deleteNeynarFrameRequest *DeleteNeynarFrameRequest
}

// API key required for authentication.
func (r ApiDeleteNeynarFrameRequest) ApiKey(apiKey string) ApiDeleteNeynarFrameRequest {
	r.apiKey = &apiKey
	return r
}

func (r ApiDeleteNeynarFrameRequest) DeleteNeynarFrameRequest(deleteNeynarFrameRequest DeleteNeynarFrameRequest) ApiDeleteNeynarFrameRequest {
	r.deleteNeynarFrameRequest = &deleteNeynarFrameRequest
	return r
}

func (r ApiDeleteNeynarFrameRequest) Execute() (*DeleteFrameResponse, *http.Response, error) {
	return r.ApiService.DeleteNeynarFrameExecute(r)
}

/*
DeleteNeynarFrame Delete a frame

Delete an existing frame, if it was made by the developer (identified by API key)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteNeynarFrameRequest
*/
func (a *FrameAPIService) DeleteNeynarFrame(ctx context.Context) ApiDeleteNeynarFrameRequest {
	return ApiDeleteNeynarFrameRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DeleteFrameResponse
func (a *FrameAPIService) DeleteNeynarFrameExecute(r ApiDeleteNeynarFrameRequest) (*DeleteFrameResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteFrameResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrameAPIService.DeleteNeynarFrame")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/farcaster/frame"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.apiKey == nil {
		return localVarReturnValue, nil, reportError("apiKey is required and must be specified")
	}
	if r.deleteNeynarFrameRequest == nil {
		return localVarReturnValue, nil, reportError("deleteNeynarFrameRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "api_key", r.apiKey, "")
	// body params
	localVarPostBody = r.deleteNeynarFrameRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchNeynarFramesRequest struct {
	ctx context.Context
	ApiService *FrameAPIService
	apiKey *string
}

// API key required for authentication.
func (r ApiFetchNeynarFramesRequest) ApiKey(apiKey string) ApiFetchNeynarFramesRequest {
	r.apiKey = &apiKey
	return r
}

func (r ApiFetchNeynarFramesRequest) Execute() ([]NeynarFrame, *http.Response, error) {
	return r.ApiService.FetchNeynarFramesExecute(r)
}

/*
FetchNeynarFrames Retrieve a list of frames

Retrieve a list of frames made by the developer (identified by API key)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFetchNeynarFramesRequest
*/
func (a *FrameAPIService) FetchNeynarFrames(ctx context.Context) ApiFetchNeynarFramesRequest {
	return ApiFetchNeynarFramesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []NeynarFrame
func (a *FrameAPIService) FetchNeynarFramesExecute(r ApiFetchNeynarFramesRequest) ([]NeynarFrame, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []NeynarFrame
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrameAPIService.FetchNeynarFrames")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/farcaster/frame/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.apiKey == nil {
		return localVarReturnValue, nil, reportError("apiKey is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "api_key", r.apiKey, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLookupNeynarFrameRequest struct {
	ctx context.Context
	ApiService *FrameAPIService
	apiKey *string
	type_ *FrameType
	uuid *string
	url *string
}

// API key required for authentication.
func (r ApiLookupNeynarFrameRequest) ApiKey(apiKey string) ApiLookupNeynarFrameRequest {
	r.apiKey = &apiKey
	return r
}

func (r ApiLookupNeynarFrameRequest) Type_(type_ FrameType) ApiLookupNeynarFrameRequest {
	r.type_ = &type_
	return r
}

// UUID of the frame to retrieve
func (r ApiLookupNeynarFrameRequest) Uuid(uuid string) ApiLookupNeynarFrameRequest {
	r.uuid = &uuid
	return r
}

// URL of the Neynar frame to retrieve
func (r ApiLookupNeynarFrameRequest) Url(url string) ApiLookupNeynarFrameRequest {
	r.url = &url
	return r
}

func (r ApiLookupNeynarFrameRequest) Execute() (*NeynarFrame, *http.Response, error) {
	return r.ApiService.LookupNeynarFrameExecute(r)
}

/*
LookupNeynarFrame Retrieve a frame by UUID or URL

Retrieve a frame either by UUID or Neynar URL

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLookupNeynarFrameRequest
*/
func (a *FrameAPIService) LookupNeynarFrame(ctx context.Context) ApiLookupNeynarFrameRequest {
	return ApiLookupNeynarFrameRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NeynarFrame
func (a *FrameAPIService) LookupNeynarFrameExecute(r ApiLookupNeynarFrameRequest) (*NeynarFrame, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NeynarFrame
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrameAPIService.LookupNeynarFrame")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/farcaster/frame"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.apiKey == nil {
		return localVarReturnValue, nil, reportError("apiKey is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	if r.uuid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uuid", r.uuid, "")
	}
	if r.url != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "url", r.url, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "api_key", r.apiKey, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostFrameActionRequest struct {
	ctx context.Context
	ApiService *FrameAPIService
	apiKey *string
	frameActionReqBody *FrameActionReqBody
}

// API key required for authentication.
func (r ApiPostFrameActionRequest) ApiKey(apiKey string) ApiPostFrameActionRequest {
	r.apiKey = &apiKey
	return r
}

func (r ApiPostFrameActionRequest) FrameActionReqBody(frameActionReqBody FrameActionReqBody) ApiPostFrameActionRequest {
	r.frameActionReqBody = &frameActionReqBody
	return r
}

func (r ApiPostFrameActionRequest) Execute() (*Frame, *http.Response, error) {
	return r.ApiService.PostFrameActionExecute(r)
}

/*
PostFrameAction Posts a frame action, cast action or a cast composer action

Post frame actions, cast actions or cast composer actions to the server  \
(In order to post any of these actions, you need to have an approved `signer_uuid`)

The POST request to the post_url has a timeout of 5 seconds for frames.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostFrameActionRequest
*/
func (a *FrameAPIService) PostFrameAction(ctx context.Context) ApiPostFrameActionRequest {
	return ApiPostFrameActionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Frame
func (a *FrameAPIService) PostFrameActionExecute(r ApiPostFrameActionRequest) (*Frame, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Frame
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrameAPIService.PostFrameAction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/farcaster/frame/action"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.apiKey == nil {
		return localVarReturnValue, nil, reportError("apiKey is required and must be specified")
	}
	if r.frameActionReqBody == nil {
		return localVarReturnValue, nil, reportError("frameActionReqBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "api_key", r.apiKey, "")
	// body params
	localVarPostBody = r.frameActionReqBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostFrameDeveloperManagedActionRequest struct {
	ctx context.Context
	ApiService *FrameAPIService
	apiKey *string
	frameDeveloperManagedActionReqBody *FrameDeveloperManagedActionReqBody
}

// API key required for authentication.
func (r ApiPostFrameDeveloperManagedActionRequest) ApiKey(apiKey string) ApiPostFrameDeveloperManagedActionRequest {
	r.apiKey = &apiKey
	return r
}

func (r ApiPostFrameDeveloperManagedActionRequest) FrameDeveloperManagedActionReqBody(frameDeveloperManagedActionReqBody FrameDeveloperManagedActionReqBody) ApiPostFrameDeveloperManagedActionRequest {
	r.frameDeveloperManagedActionReqBody = &frameDeveloperManagedActionReqBody
	return r
}

func (r ApiPostFrameDeveloperManagedActionRequest) Execute() (*Frame, *http.Response, error) {
	return r.ApiService.PostFrameDeveloperManagedActionExecute(r)
}

/*
PostFrameDeveloperManagedAction Posts a frame signature packet

Post a frame action that has been signed with a developer managed signer

The POST request to the post_url has a timeout of 5 seconds.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostFrameDeveloperManagedActionRequest
*/
func (a *FrameAPIService) PostFrameDeveloperManagedAction(ctx context.Context) ApiPostFrameDeveloperManagedActionRequest {
	return ApiPostFrameDeveloperManagedActionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Frame
func (a *FrameAPIService) PostFrameDeveloperManagedActionExecute(r ApiPostFrameDeveloperManagedActionRequest) (*Frame, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Frame
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrameAPIService.PostFrameDeveloperManagedAction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/farcaster/frame/developer_managed/action"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.apiKey == nil {
		return localVarReturnValue, nil, reportError("apiKey is required and must be specified")
	}
	if r.frameDeveloperManagedActionReqBody == nil {
		return localVarReturnValue, nil, reportError("frameDeveloperManagedActionReqBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "api_key", r.apiKey, "")
	// body params
	localVarPostBody = r.frameDeveloperManagedActionReqBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPublishNeynarFrameRequest struct {
	ctx context.Context
	ApiService *FrameAPIService
	apiKey *string
	neynarFrameCreationRequest *NeynarFrameCreationRequest
}

// API key required for authentication.
func (r ApiPublishNeynarFrameRequest) ApiKey(apiKey string) ApiPublishNeynarFrameRequest {
	r.apiKey = &apiKey
	return r
}

func (r ApiPublishNeynarFrameRequest) NeynarFrameCreationRequest(neynarFrameCreationRequest NeynarFrameCreationRequest) ApiPublishNeynarFrameRequest {
	r.neynarFrameCreationRequest = &neynarFrameCreationRequest
	return r
}

func (r ApiPublishNeynarFrameRequest) Execute() (*NeynarFrame, *http.Response, error) {
	return r.ApiService.PublishNeynarFrameExecute(r)
}

/*
PublishNeynarFrame Create a new frame

Create a new frame with a list of pages.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPublishNeynarFrameRequest
*/
func (a *FrameAPIService) PublishNeynarFrame(ctx context.Context) ApiPublishNeynarFrameRequest {
	return ApiPublishNeynarFrameRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NeynarFrame
func (a *FrameAPIService) PublishNeynarFrameExecute(r ApiPublishNeynarFrameRequest) (*NeynarFrame, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NeynarFrame
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrameAPIService.PublishNeynarFrame")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/farcaster/frame"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.apiKey == nil {
		return localVarReturnValue, nil, reportError("apiKey is required and must be specified")
	}
	if r.neynarFrameCreationRequest == nil {
		return localVarReturnValue, nil, reportError("neynarFrameCreationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "api_key", r.apiKey, "")
	// body params
	localVarPostBody = r.neynarFrameCreationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateNeynarFrameRequest struct {
	ctx context.Context
	ApiService *FrameAPIService
	apiKey *string
	neynarFrameUpdateRequest *NeynarFrameUpdateRequest
}

// API key required for authentication.
func (r ApiUpdateNeynarFrameRequest) ApiKey(apiKey string) ApiUpdateNeynarFrameRequest {
	r.apiKey = &apiKey
	return r
}

func (r ApiUpdateNeynarFrameRequest) NeynarFrameUpdateRequest(neynarFrameUpdateRequest NeynarFrameUpdateRequest) ApiUpdateNeynarFrameRequest {
	r.neynarFrameUpdateRequest = &neynarFrameUpdateRequest
	return r
}

func (r ApiUpdateNeynarFrameRequest) Execute() (*NeynarFrame, *http.Response, error) {
	return r.ApiService.UpdateNeynarFrameExecute(r)
}

/*
UpdateNeynarFrame Update an existing frame

Update an existing frame with a list of pages, if it was made by the developer (identified by API key)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateNeynarFrameRequest
*/
func (a *FrameAPIService) UpdateNeynarFrame(ctx context.Context) ApiUpdateNeynarFrameRequest {
	return ApiUpdateNeynarFrameRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NeynarFrame
func (a *FrameAPIService) UpdateNeynarFrameExecute(r ApiUpdateNeynarFrameRequest) (*NeynarFrame, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NeynarFrame
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrameAPIService.UpdateNeynarFrame")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/farcaster/frame"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.apiKey == nil {
		return localVarReturnValue, nil, reportError("apiKey is required and must be specified")
	}
	if r.neynarFrameUpdateRequest == nil {
		return localVarReturnValue, nil, reportError("neynarFrameUpdateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "api_key", r.apiKey, "")
	// body params
	localVarPostBody = r.neynarFrameUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidateFrameRequest struct {
	ctx context.Context
	ApiService *FrameAPIService
	apiKey *string
	validateFrameRequest *ValidateFrameRequest
}

// API key required for authentication.
func (r ApiValidateFrameRequest) ApiKey(apiKey string) ApiValidateFrameRequest {
	r.apiKey = &apiKey
	return r
}

func (r ApiValidateFrameRequest) ValidateFrameRequest(validateFrameRequest ValidateFrameRequest) ApiValidateFrameRequest {
	r.validateFrameRequest = &validateFrameRequest
	return r
}

func (r ApiValidateFrameRequest) Execute() (*ValidateFrameActionResponse, *http.Response, error) {
	return r.ApiService.ValidateFrameExecute(r)
}

/*
ValidateFrame Validates a frame action against Farcaster Hub

Validates a frame against by an interacting user against a Farcaster Hub \
(In order to validate a frame, message bytes from Frame Action must be provided in hex)


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiValidateFrameRequest
*/
func (a *FrameAPIService) ValidateFrame(ctx context.Context) ApiValidateFrameRequest {
	return ApiValidateFrameRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ValidateFrameActionResponse
func (a *FrameAPIService) ValidateFrameExecute(r ApiValidateFrameRequest) (*ValidateFrameActionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ValidateFrameActionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrameAPIService.ValidateFrame")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/farcaster/frame/validate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.apiKey == nil {
		return localVarReturnValue, nil, reportError("apiKey is required and must be specified")
	}
	if r.validateFrameRequest == nil {
		return localVarReturnValue, nil, reportError("validateFrameRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "api_key", r.apiKey, "")
	// body params
	localVarPostBody = r.validateFrameRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidateFrameAnalyticsRequest struct {
	ctx context.Context
	ApiService *FrameAPIService
	apiKey *string
	frameUrl *string
	analyticsType *ValidateFrameAnalyticsType
	start *time.Time
	stop *time.Time
	aggregateWindow *string
}

// API key required for authentication.
func (r ApiValidateFrameAnalyticsRequest) ApiKey(apiKey string) ApiValidateFrameAnalyticsRequest {
	r.apiKey = &apiKey
	return r
}

func (r ApiValidateFrameAnalyticsRequest) FrameUrl(frameUrl string) ApiValidateFrameAnalyticsRequest {
	r.frameUrl = &frameUrl
	return r
}

func (r ApiValidateFrameAnalyticsRequest) AnalyticsType(analyticsType ValidateFrameAnalyticsType) ApiValidateFrameAnalyticsRequest {
	r.analyticsType = &analyticsType
	return r
}

func (r ApiValidateFrameAnalyticsRequest) Start(start time.Time) ApiValidateFrameAnalyticsRequest {
	r.start = &start
	return r
}

func (r ApiValidateFrameAnalyticsRequest) Stop(stop time.Time) ApiValidateFrameAnalyticsRequest {
	r.stop = &stop
	return r
}

// Required for &#x60;analytics_type&#x3D;interactions-per-cast&#x60;
func (r ApiValidateFrameAnalyticsRequest) AggregateWindow(aggregateWindow string) ApiValidateFrameAnalyticsRequest {
	r.aggregateWindow = &aggregateWindow
	return r
}

func (r ApiValidateFrameAnalyticsRequest) Execute() (*FrameValidateAnalyticsResponse, *http.Response, error) {
	return r.ApiService.ValidateFrameAnalyticsExecute(r)
}

/*
ValidateFrameAnalytics Retrieve analytics for the frame

Retrieve analytics for total-interactors, interactors, nteractions-per-cast and input-text.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiValidateFrameAnalyticsRequest
*/
func (a *FrameAPIService) ValidateFrameAnalytics(ctx context.Context) ApiValidateFrameAnalyticsRequest {
	return ApiValidateFrameAnalyticsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FrameValidateAnalyticsResponse
func (a *FrameAPIService) ValidateFrameAnalyticsExecute(r ApiValidateFrameAnalyticsRequest) (*FrameValidateAnalyticsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FrameValidateAnalyticsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrameAPIService.ValidateFrameAnalytics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/farcaster/frame/validate/analytics"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.apiKey == nil {
		return localVarReturnValue, nil, reportError("apiKey is required and must be specified")
	}
	if r.frameUrl == nil {
		return localVarReturnValue, nil, reportError("frameUrl is required and must be specified")
	}
	if r.analyticsType == nil {
		return localVarReturnValue, nil, reportError("analyticsType is required and must be specified")
	}
	if r.start == nil {
		return localVarReturnValue, nil, reportError("start is required and must be specified")
	}
	if r.stop == nil {
		return localVarReturnValue, nil, reportError("stop is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "frame_url", r.frameUrl, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "analytics_type", r.analyticsType, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "stop", r.stop, "")
	if r.aggregateWindow != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "aggregate_window", r.aggregateWindow, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "api_key", r.apiKey, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidateFrameListRequest struct {
	ctx context.Context
	ApiService *FrameAPIService
	apiKey *string
}

// API key required for authentication.
func (r ApiValidateFrameListRequest) ApiKey(apiKey string) ApiValidateFrameListRequest {
	r.apiKey = &apiKey
	return r
}

func (r ApiValidateFrameListRequest) Execute() (*FrameValidateListResponse, *http.Response, error) {
	return r.ApiService.ValidateFrameListExecute(r)
}

/*
ValidateFrameList Retrieve a list of all the frames validated by a user

Retrieve a list of all the frames validated by a user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiValidateFrameListRequest
*/
func (a *FrameAPIService) ValidateFrameList(ctx context.Context) ApiValidateFrameListRequest {
	return ApiValidateFrameListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FrameValidateListResponse
func (a *FrameAPIService) ValidateFrameListExecute(r ApiValidateFrameListRequest) (*FrameValidateListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FrameValidateListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FrameAPIService.ValidateFrameList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/farcaster/frame/validate/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.apiKey == nil {
		return localVarReturnValue, nil, reportError("apiKey is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "api_key", r.apiKey, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorRes
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
